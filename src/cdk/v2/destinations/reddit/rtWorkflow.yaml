bindings:
  - path: ./utils
  - path: ./config
  - name: isDefinedAndNotNull
    path: ../../../../v0/util
  - name: combineBatchRequestsWithSameJobIds
    path: ../../../../v0/util

steps:
  - name: validateInput
    template: |
      $.assert(Array.isArray(^) && ^.length > 0, "Invalid event array")

  - name: decideVersion
    template: |
      $.decideVersion(^.[0].destination)

  - name: transformWithV2
    condition: $.outputs.decideVersion === "v2"
    externalWorkflow:
      path: ./procWorkflow.yaml
      bindings:
        - name: batchMode
          value: true
    loopOverInput: true

  - name: transformWithV3
    condition: $.outputs.decideVersion === "v3"
    externalWorkflow:
      path: ./procWorkflowV3.yaml
      bindings:
        - name: batchMode
          value: true
    loopOverInput: true

  - name: transform
    condition: $.outputs.decideVersion === "v2"
    template: |
      $.outputs.transformWithV2
    else:
      name: transformV3Output
      template: |
        $.outputs.transformWithV3

  - name: successfulEvents
    template: |
      $.outputs.transform#idx.output.({
        "message": .[],
        "destination": ^ [idx].destination,
        "metadata": ^ [idx].metadata
      })[]
  - name: failedEvents
    template: |
      $.outputs.transform#idx.error.({
        "metadata": ^[idx].metadata[],
        "destination": ^[idx].destination,
        "batched": false,
        "statusCode": .status,
        "error": .message,
        "statTags": .originalError.statTags
      })[]

  - name: batchSuccessfulEvents
    description: Batches the successfulEvents based on the dontBatch in metadata and test_id in message body. If test_id is present in any of the transformed events, it is not batched.
    condition: $.outputs.successfulEvents.length
    template: |
      const nonBatchableEvents =  $.outputs.successfulEvents{.metadata.dontBatch || .message.[0].body.JSON.data.test_id}[];
      const batchableEvents = $.outputs.successfulEvents{!.metadata.dontBatch && !.message.[0].body.JSON.data.test_id}[];
      const nonBatchableEventsChunks = $.chunk(nonBatchableEvents, 1);
      const batchableEventsChunks = $.chunk(batchableEvents, $.maxBatchSize);
      let batches = [...$.batchEventChunks(nonBatchableEventsChunks), ...$.batchEventChunks(batchableEventsChunks)];
      batches@batch.({
        "batchedRequest": {
          "body": {
            "JSON": batch.message.body.JSON,
            "JSON_ARRAY": {},
            "XML": {},
            "FORM": {}
          },
          "version": "1",
          "type": "REST",
          "method": "POST",
          "endpoint": batch.message.endpoint,
          "headers": batch.message.headers,
          "params": {},
          "files": {}
        },
        "metadata": batch.metadata,
        "batched": true,
        "statusCode": 200,
        "destination": batch.destination
      })[];
    else:
      name: returnEmptyOuput
      template: '[]'

  - name: finalPayload
    template: |
      [...$.combineBatchRequestsWithSameJobIds($.outputs.batchSuccessfulEvents), ...$.outputs.failedEvents]

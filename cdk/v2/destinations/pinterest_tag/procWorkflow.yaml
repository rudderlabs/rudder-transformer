options:
  templateType: jsontemplate
bindings:
  - name: EventType
    path: ../../../../constants
  - name: SourceKeys
    path: ../../../../v0/util/data/GenericFieldMapping.json
    exportAll: true
  - path: ../../../../v0/destinations/pinterest_tag/utils
  - name: ENDPOINT
    path: ../../../../v0/destinations/pinterest_tag/config
steps:
  - name: checkIfProcessed
    condition: .message.statusCode
    template: |
      $.context.batchMode ? .message.body.JSON : .message
    onComplete: return
  - name: messageType
    template: |
      .message.type.toLowerCase()
  - name: validateInput
    template: |
      let messageType = $.outputs.messageType;
      $.assert(.destination.Config.advertiserId, "Advertiser Id not found. Aborting");
      $.assert(messageType, "Message type is not present. Aborting message.");
      $.assert(messageType in $.EventType.([.TRACK, .PAGE, .SCREEN]), 
        "message type " + messageType + " is not supported")
      
  - name: validateInputForTrack
    description: Additional validation for Track events
    condition: $.outputs.messageType === $.EventType.TRACK
    template: |
        .message.($.assert(.event || .name, "event_name could not be mapped. Aborting."))
  - name: commonFields
    description: |
      Builds common fields in destination payload.
      ref: https://s.pinimg.com/ct/docs/conversions_api/dist/v3.html
    template: |
      .message.({
        "event_time": $floor($getByPaths($, $SourceKeys.timestamp)[0].$toMillis()/1000),
        "event_source_url": (
          $url := $getByPaths($, $SourceKeys.pageUrl)[0];
          $length($url) > 0 ? $url;
        ),
        "action_source": .traits.action_source ?? 
                         .context.traits.action_source ?? 
                         .traits.actionSource ??
                         .context.traits.actionSource ??
                         .properties.(.action_source ?? .actionSource)
                         .channel,
        "app_name": .properties.appName ?? .context.app.name,
        "app_version" : .properties.appVersion ?? .context.app.version,
        "device_brand": .properties.manufacturer ?? .context.device.manufacturer,
        "device_model": .properties.deviceModel ?? context.device.model,
        "device_type": .properties.deviceType ?? context.device.type,
        "os_version": .context.os.version,
        "language": .properties.language ??
                    .context.traits.language ??
                    .context.locale,
        "opt_out": !.context.device.adTrackingEnabled,
        "event_id":[$getByPaths($, ^.destination.Config.deduplicationKey), messageId][0],
        "app_id": ^.destination.Config.appId,
        "advertiser_id": ^.destination.Config.advertiserId
      })
  - name: validateCommonFields
    template: |
      let {event_time, action_source} = $.outputs.commonFields.{["event_time", "action_source"]};
      $.assert(event_time, "event_time is required");
      $.assert(action_source, "action_source is required");
      $.assert(action_source in $.VALID_ACTION_SOURCES, 
          "Action source must be one of " + $.VALID_ACTION_SOURCES.join(", "))
  - name: userFields
    description: Personally identifiable fields
    template: |
        let gender = .message.(.traits.gender ?? .context.traits.gender);
        gender = gender && (
                  (gender in ["f", "F", "Female", "female", "FEMALE"] ? "f") ??
                  (gender in ["m", "M", "Male", "male", "MALE"] ? "m": gender)
                );
        let userFields = .message.{
          "em": $getByPaths($, $SourceKeys.email)[0],
          "ph": $getByPaths($, $SourceKeys.phone)[0],
          "ge": gender,
          "db": $getByPaths($, $SourceKeys.birthday)[0],
          "ln": $getByPaths($, $SourceKeys.lastName)[0],
          "fn": $getByPaths($, $SourceKeys.firstName)[0],
          "ct": (.traits.address.city ?? .context.traits.address.city).toLowerCase(),
          "st": (.traits.address.state ?? .context.traits.address.state).toLowerCase(),
          "zip": (.traits.address.zip ?? .context.traits.address.zip).toLowerCase(),
          "country": (.traits.address.country ?? .context.traits.address.country).toLowerCase(),
          "hashed_maids": context.device.advertisingId,
          "client_ip_address": .context.ip ?? .request_ip,
          "client_user_agent": .context.userAgent
        };
        .destination.Config.sendingUnHashedData ? 
          $.processUserPayload(userFields) :
          $.processHashedUserPayload(userFields, .message)
  - name: validateUserFields
    template: |
      const requiredFieldsCondition = $.outputs.userFields.(.em || .hashed_maids || (.client_ip_address && .client_user_agent));
      $.assert(requiredFieldsCondition, "It is required at least one of em, hashed_maids or" +
            " pair of client_ip_address and client_user_agent.")
      
  - name: ecomFields
    condition: $outputs.messageType = $EventType.TRACK
    steps:
      - name: customFields
        template: |
          .message.{
            "currency": .properties.currency,
            "value": .properties.(.value ?? .total ?? .revenue),
            "num_items": Number(.properties.numOfItems),
            "order_id": .properties.order_id,
            "search_string": .properties.query
          }
      - name: productFields
        condition: .message.properties.products
        description: When event contains multiple products
        template: |
          {
             "num_items": $sum(message.properties.products.quantity.$number()),
             "content_ids": .message.properties.products.(.product_id ?? .sku ?? .id),
             "contents": message.properties@prop.products.({
               "quantity": Number(.quantity ?? prop.quantity ?? 1),
               "item_price": String(.price ?? prop.price)
             })
           }
        else: 
          name: singleProductFields
          template: |
            message.properties.{
              "num_items": $number(.quantity),
              "content_ids": (.product_id ?? .sku ? .id)[],
              "contents": [{
                "quantity": Number(.quantity ?? 1),
                "item_price": String(.price)
              }]
            }
      - name: combineAllEcomFields
        template: |
          $outputs.ecomFields.(Object.assign(.productFields, .customFields))
  - name: basePayload
    template: |
      $.outputs.({
        ...(.commonFields),
        "user_data": .userFields, 
        "custom_data": .ecomFields
      })
  - name: eventNames
    description: Event names for page message type
    condition: $.outputs.messageType === $.EventType.PAGE
    template: |
      .message.category ? [ "ViewCategory" ] : [ "PageVisit" ])
    else:
      name: eventNamesForOthers
      template: |
        (
          $event := message.[event, name][0];
          $eventMap := destination.Config.eventsMapping.{from: to};
          $eventNames := $lookup($eventMap, $event);
          $count($eventNames) = 0 ? $eventNames := $ecomEventMaps[$lowercase($event) in src].dest;
          $count($eventNames) = 0 ? $eventNames := [$event];
          $eventNames
        )
  - name: destEvents
    template: |
      $outputs.eventNames.($merge([%.basePayload, {"event_name": $}])) ~> $toArray
  - name: buildResponse
    condition: $not($exists($context.batchMode))
    template: |
      $outputs.destEvents.{
        "body": {
          "JSON": $,
          "JSON_ARRAY": {},
          "XML": {},
          "FORM": {}
        },
        "version": "1",
        "type": "REST",
        "method": "POST",
        "endpoint": $ENDPOINT,
        "headers": {
          "Content-Type": "application/json"
        },
        "params": {},
        "files": {}
      } ~> $toArray

import { ArraySpreader } from '../arraySpreader';
import { SpreaderContext } from '../types/spreader';

describe('arraySpreader', () => {
  // Generated by Qodo Gen

  describe('ArraySpreader', () => {
    // Applies spread data to each item in an array when target has arrayPath
    it('should apply spread data to each item in an array when target has arrayPath', async () => {
      // Arrange
      const config = {
        name: 'tenantSpreader',
        rules: [
          {
            source: { type: 'header' as const, path: 'x-tenant-id' },
            target: { path: 'tenantId', arrayPath: 'items' },
          },
        ],
      };

      const arraySpreader = new ArraySpreader(config);

      const ctx = {
        get: jest.fn().mockReturnValue('tenant-123'),
        request: {
          body: {
            items: [{ name: 'Item 1' }, { name: 'Item 2' }, { name: 'Item 3' }],
          },
        },
        spreadData: {
          tenantId: 'tenant-123',
        },
      } as unknown as SpreaderContext;

      // Act
      await arraySpreader.middleware()(ctx, jest.fn());

      // Assert
      expect((ctx.request.body as any).items[0].tenantId).toBe('tenant-123');
      expect((ctx.request.body as any).items[1].tenantId).toBe('tenant-123');
      expect((ctx.request.body as any).items[2].tenantId).toBe('tenant-123');
    });

    // Correctly sets nested values in array items using dot notation paths
    it('should set nested values in array items using dot notation paths when target has arrayPath', async () => {
      // Arrange
      const config = {
        name: 'userSpreader',
        rules: [
          {
            source: { type: 'body' as const, path: 'user.id' },
            target: { path: 'userId', arrayPath: 'users' },
          },
        ],
      };

      const arraySpreader = new ArraySpreader(config);

      const ctx = {
        request: {
          body: {
            users: [{ name: 'User 1' }, { name: 'User 2' }, { name: 'User 3' }],
            user: { id: 'user-456' },
          },
        },
      } as unknown as SpreaderContext;

      // Act
      await arraySpreader.middleware()(ctx, jest.fn());
      // Assert
      expect((ctx.request.body as any).users[0].userId).toBe('user-456');
      expect((ctx.request.body as any).users[1].userId).toBe('user-456');
      expect((ctx.request.body as any).users[2].userId).toBe('user-456');
    });

    // Handles empty arrays without errors
    it('should handle empty arrays without errors', async () => {
      // Arrange
      const config = {
        name: 'tenantSpreader',
        rules: [
          {
            source: { type: 'header' as const, path: 'x-tenant-id' },
            target: { path: 'tenantId', arrayPath: 'items' },
          },
        ],
      };

      const arraySpreader = new ArraySpreader(config);

      const ctx = {
        get: jest.fn().mockReturnValue('tenant-123'),
        request: {
          body: {
            items: [],
          },
        },
        spreadData: {
          tenantId: 'tenant-123',
        },
      } as unknown as SpreaderContext;

      // Act & Assert
      await expect(arraySpreader.middleware()(ctx, jest.fn())).resolves.not.toThrow();
      expect((ctx.request.body as any).items).toEqual([]);
    });
  });
});

const { OperatorType } = require('@rudderstack/json-template-engine');
const {
  groupSubscribeResponsesUsingListIdV2,
  populateArrWithRespectiveProfileData,
  generateBatchedSubscriptionRequest,
} = require('./batchUtil');
const { revision } = require('./config');

describe('groupSubscribeResponsesUsingListIdV2', () => {
  // Groups subscription responses by listId correctly
  it('should group subscription responses by listId correctly when given a valid list', () => {
    const subscribeResponseList = [
      { payload: { listId: 'list_1', profile: {} }, metadata: {} },
      { payload: { listId: 'list_1', profile: {} }, metadata: {} },
      { payload: { listId: 'list_2', profile: {} }, metadata: {} },
    ];

    const expectedOutput = {
      list_1: [
        { payload: { listId: 'list_1', profile: {} }, metadata: {} },
        { payload: { listId: 'list_1', profile: {} }, metadata: {} },
      ],
      list_2: [{ payload: { listId: 'list_2', profile: {} }, metadata: {} }],
    };

    const result = groupSubscribeResponsesUsingListIdV2(subscribeResponseList);

    expect(result).toEqual(expectedOutput);
  });

  // Handles empty subscription response list
  it('should return an empty object when given an empty subscription response list', () => {
    const subscribeResponseList = [];

    const expectedOutput = {};

    const result = groupSubscribeResponsesUsingListIdV2(subscribeResponseList);

    expect(result).toEqual(expectedOutput);
  });
});

describe('populateArrWithRespectiveProfileData', () => {
  // Correctly populates array when all profiles have corresponding metadata
  it('should correctly populate array when all profiles have corresponding metadata', () => {
    const profileSubscriptionAndMetadataArr = [
      { profiles: [], metadataList: [{ jobId: '1' }], subscriptions: [] },
      { profiles: [], metadataList: [{ jobId: '2' }], subscriptions: [] },
    ];
    const metadataIndexMap = new Map([
      ['1', 0],
      ['2', 1],
    ]);
    const profiles = [
      { payload: { name: 'John' }, metadata: { jobId: '1' } },
      { payload: { name: 'Doe' }, metadata: { jobId: '2' } },
    ];

    const result = populateArrWithRespectiveProfileData(
      profileSubscriptionAndMetadataArr,
      metadataIndexMap,
      profiles,
    );

    expect(result[0].profiles).toEqual([{ name: 'John' }]);
    expect(result[1].profiles).toEqual([{ name: 'Doe' }]);
  });

  // Handles empty profileSubscriptionAndMetadataArr input
  it('should handle empty profileSubscriptionAndMetadataArr input', () => {
    const profileSubscriptionAndMetadataArr = [];
    const metadataIndexMap = new Map();
    const profiles = [{ payload: { name: 'John' }, metadata: { jobId: '1' } }];

    const result = populateArrWithRespectiveProfileData(
      profileSubscriptionAndMetadataArr,
      metadataIndexMap,
      profiles,
    );

    expect(result).toEqual([
      {
        profiles: [{ name: 'John' }],
        metadataList: [{ jobId: '1' }],
      },
    ]);
  });
});

// Generated by CodiumAI

describe('generateBatchedSubscriptionRequest', () => {
  // Generates a batched subscription request with valid subscription and destination inputs
  it('should generate a valid batched subscription request when given valid subscription and destination inputs', () => {
    const subscription = {
      listId: 'test-list-id',
      subscriptionProfileList: [[{ id: 'profile1' }, { id: 'profile2' }], [{ id: 'profile3' }]],
      operation: 'subscribe',
    };
    const destination = {
      Config: {
        privateApiKey: 'test-api-key',
      },
    };
    const expectedRequest = {
      version: '1',
      type: 'REST',
      method: 'POST',
      endpoint: 'https://a.klaviyo.com/api/profile-subscription-bulk-create-jobs',
      headers: {
        Authorization: 'Klaviyo-API-Key test-api-key',
        'Content-Type': 'application/json',
        Accept: 'application/json',
        revision,
      },
      params: {},
      body: {
        JSON: {
          data: {
            type: 'profile-subscription-bulk-create-job',
            attributes: {
              profiles: { data: [{ id: 'profile1' }, { id: 'profile2' }, { id: 'profile3' }] },
            },
            relationships: {
              list: {
                data: {
                  type: 'list',
                  id: 'test-list-id',
                },
              },
            },
          },
        },
        JSON_ARRAY: {},
        XML: {},
        FORM: {},
      },
      files: {},
    };
    const result = generateBatchedSubscriptionRequest(subscription, destination);
    expect(result).toEqual(expectedRequest);
  });

  // Handles empty subscriptionProfileList gracefully
  it('should handle empty subscriptionProfileList gracefully', () => {
    const subscription = {
      listId: 'test-list-id',
      subscriptionProfileList: [],
      operation: 'subscribe',
    };
    const destination = {
      Config: {
        privateApiKey: 'test-api-key',
      },
    };
    const expectedRequest = {
      version: '1',
      type: 'REST',
      method: 'POST',
      endpoint: 'https://a.klaviyo.com/api/profile-subscription-bulk-create-jobs',
      headers: {
        Authorization: 'Klaviyo-API-Key test-api-key',
        'Content-Type': 'application/json',
        Accept: 'application/json',
        revision,
      },
      params: {},
      body: {
        JSON: {
          data: {
            type: 'profile-subscription-bulk-create-job',
            attributes: { profiles: { data: [] } },
            relationships: {
              list: {
                data: {
                  type: 'list',
                  id: 'test-list-id',
                },
              },
            },
          },
        },
        JSON_ARRAY: {},
        XML: {},
        FORM: {},
      },
      files: {},
    };
    const result = generateBatchedSubscriptionRequest(subscription, destination);
    expect(result).toEqual(expectedRequest);
  });
});
